<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>JavaScript on Mark Birger</title><link>https://kusha.github.io/tags/javascript/</link><description>Recent content in JavaScript on Mark Birger</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>Mark Birger</copyright><lastBuildDate>Sun, 10 Nov 2019 09:00:00 +0000</lastBuildDate><atom:link href="https://kusha.github.io/tags/javascript/index.xml" rel="self" type="application/rss+xml"/><item><title>JavaScript URI エンコーディング</title><link>https://kusha.github.io/posts/2019-11-10-encodeuricomponent/</link><pubDate>Sun, 10 Nov 2019 09:00:00 +0000</pubDate><guid>https://kusha.github.io/posts/2019-11-10-encodeuricomponent/</guid><description>まとめ encodeURI()とencodeURIComponent()はRFC 2396準拠である。 encodeURI() は完全な URI を表すのに必要な文字 (Reserved Characters) はエンコードしません。 また、予約されていないが &amp;ldquo;そのまま&amp;rdquo; URI に使用できる(Unreserved Marks) 文字をエンコードしません。 encodeURIComponent() は &amp;ldquo;Unreserved Marks&amp;rdquo; 文字をエンコードしません。
var set1 = &amp;#34;;,/?:@&amp;amp;=+$#&amp;#34;; // Reserved Characters var set2 = &amp;#34;-_.!~*&amp;#39;()&amp;#34;; // Unreserved Marks console.log(encodeURI(set1)); // ;,/?:@&amp;amp;=+$ console.log(encodeURI(set2)); // -_.!~*&amp;#39;() console.log(encodeURIComponent(set1)); // %3B%2C%2F%3F%3A%40%26%3D%2B%24 console.log(encodeURIComponent(set2)); // -_.!~*&amp;#39;() rfc2396 appendix-A https://tools.ietf.org/html/rfc2396#appendix-A
URI-reference = [ absoluteURI | relativeURI ] [ &amp;quot;#&amp;quot; fragment ] absoluteURI = scheme &amp;quot;:&amp;quot; ( hier_part | opaque_part ) relativeURI = ( net_path | abs_path | rel_path ) [ &amp;quot;?</description></item><item><title>JavaScript Comparison operation at a glance</title><link>https://kusha.github.io/posts/2019-03-28-javascript-comparison/</link><pubDate>Thu, 28 Mar 2019 09:00:00 +0000</pubDate><guid>https://kusha.github.io/posts/2019-03-28-javascript-comparison/</guid><description>When given a scenario like:
console.log(null &amp;gt; -1) //true It produces true, which makes me think null is treated as 0. But when I run:
console.log(null == 0) // false console.log(null &amp;gt; 0) // false console.log(null &amp;lt; 0) // false They all output false!
I googled a lot and finally found answers in Ecma-262 Specification.
The comparison x == y, where x and y are values, produces true or false. Such a comparison is performed as follows:</description></item><item><title>Js tips I can't remember</title><link>https://kusha.github.io/posts/2019-03-22-js-tips/</link><pubDate>Fri, 22 Mar 2019 09:00:00 +0000</pubDate><guid>https://kusha.github.io/posts/2019-03-22-js-tips/</guid><description>&lt;h2 id="__proto__-vs-prototype">&lt;code>__proto__&lt;/code> VS &lt;code>prototype&lt;/code>&lt;/h2>
&lt;blockquote>
&lt;p>&lt;code>__proto__&lt;/code> is the actual object that is used in the lookup chain to resolve methods and others. &lt;code>prototype&lt;/code> is the object that is used to build &lt;code>__proto__&lt;/code> when creating an object with &lt;code>new&lt;/code>.&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>The &amp;ldquo;cool kids&amp;rdquo; in JavaScript would generally pronounce &lt;code>__proto__&lt;/code> as &amp;ldquo;&lt;strong>dunder proto&lt;/strong>&amp;rdquo;.&lt;/p>
&lt;/blockquote>
&lt;p>&lt;a href="https://stackoverflow.com/questions/9959727/proto-vs-prototype-in-javascript">https://stackoverflow.com/questions/9959727/proto-vs-prototype-in-javascript&lt;/a>&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-javascript" data-lang="javascript">( &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#a6e22e">Foo&lt;/span> ).&lt;span style="color:#a6e22e">__proto__&lt;/span> &lt;span style="color:#f92672">===&lt;/span> &lt;span style="color:#a6e22e">Foo&lt;/span>.&lt;span style="color:#a6e22e">prototype&lt;/span>; &lt;span style="color:#75715e">// true
&lt;/span>&lt;span style="color:#75715e">&lt;/span>( &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#a6e22e">Foo&lt;/span> ).&lt;span style="color:#a6e22e">prototype&lt;/span> &lt;span style="color:#f92672">===&lt;/span> &lt;span style="color:#66d9ef">undefined&lt;/span>; &lt;span style="color:#75715e">// true
&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Bind specific arguments of a function</title><link>https://kusha.github.io/posts/2019-03-08-es6-bind-trick/</link><pubDate>Fri, 08 Mar 2019 09:00:00 +0000</pubDate><guid>https://kusha.github.io/posts/2019-03-08-es6-bind-trick/</guid><description>To bind specific (nth) arguments of a function, we can write a decorator instead of using Function.bind():
function func(p1, p2, p3) { console.log(p1, p2, p3); } // the binding starts after however many are passed in. function decorator(...bound_args) { return function(...args) { return func(...args, ...bound_args); }; } // bind the last parameter let f = decorator(&amp;#34;3&amp;#34;); f(&amp;#34;a&amp;#34;, &amp;#34;b&amp;#34;); // a b 3 // bind the last two parameter let f2 = decorator(&amp;#34;2&amp;#34;, &amp;#34;3&amp;#34;) f2(&amp;#34;a&amp;#34;); // a 2 3 Even if we want to bind just the nth argument, we can do as follows:</description></item><item><title>Object.assign() with accessor descriptor</title><link>https://kusha.github.io/posts/2019-03-08-object-assign-with-accessor-descriptor/</link><pubDate>Fri, 08 Mar 2019 09:00:00 +0000</pubDate><guid>https://kusha.github.io/posts/2019-03-08-object-assign-with-accessor-descriptor/</guid><description>&lt;p>&lt;a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign#Copying_accessors">MDN docs:&lt;/a>&lt;/p>
&lt;blockquote>
&lt;p>The Object.assign() method only copies enumerable and own properties from a source object to a target object. It uses [[Get]] on the source and [[Set]] on the target, so it will invoke getters and setters. Therefore it assigns properties versus just copying or defining new properties. This may make it unsuitable for merging new properties into a prototype if the merge sources contain getters.&lt;/p>
&lt;/blockquote>
&lt;p>For example&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-js" data-lang="js">&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Cat&lt;/span> {
&lt;span style="color:#a6e22e">constructor&lt;/span>(&lt;span style="color:#a6e22e">name&lt;/span>) {
&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">_name&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">name&lt;/span>;
}
&lt;span style="color:#a6e22e">get&lt;/span> &lt;span style="color:#a6e22e">name&lt;/span>() {
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">_name&lt;/span>;
}
&lt;span style="color:#a6e22e">set&lt;/span> &lt;span style="color:#a6e22e">name&lt;/span>(&lt;span style="color:#a6e22e">value&lt;/span>) {
&lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">_name&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">value&lt;/span>;
}
}
&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">nyannko&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#a6e22e">Cat&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;nyannko&amp;#34;&lt;/span>);
&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">copy&lt;/span> &lt;span style="color:#f92672">=&lt;/span> Object.&lt;span style="color:#a6e22e">assign&lt;/span>({}, &lt;span style="color:#a6e22e">nyannko&lt;/span>)
&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#a6e22e">nyannko&lt;/span>.&lt;span style="color:#a6e22e">name&lt;/span>) &lt;span style="color:#75715e">// nyannko
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#a6e22e">copy&lt;/span>.&lt;span style="color:#a6e22e">name&lt;/span>) &lt;span style="color:#75715e">// undefined
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>The &lt;code>name&lt;/code> property is lost.&lt;/p></description></item><item><title>VueのNavigation Guards</title><link>https://kusha.github.io/posts/2019-01-19-vue-navigation-guards/</link><pubDate>Fri, 25 Jan 2019 09:00:00 +0000</pubDate><guid>https://kusha.github.io/posts/2019-01-19-vue-navigation-guards/</guid><description>Navigation guards are provided by vue-router. Three ways to hook:
globally per-route in-component NOTE:
Params or query changes won&amp;rsquo;t trigger enter/leave navigation guards. You can either watch the $route object to react to those changes, or use the beforeRouteUpdate in-component guard. Make sure to always call the next function, otherwise the hook will never be resolved. Global const router = new VueRouter({ ... }) // Before Guards router.</description></item></channel></rss>